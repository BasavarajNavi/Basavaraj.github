# 
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Loading the dataset
df=pd.read_csv(r"C:\Users\bnavi\Desktop\Wysa\spotify_2023.csv")
df.head(2)

# Exploratory Data Analysis

#The dataset provided contains information about various music tracks. Here's an explanation of each column:

#  track_name: The name of the music track.
#  artist(s)_name: The name of the artist or artists who created the track. If there are multiple artists, they are separated by commas.
#  artist_count: The number of artists involved in creating the track.
#  released_year: The year when the track was released.
#  released_month: The month when the track was released.
#  released_day: The day of the month when the track was released.
#  in_spotify_playlists: Number of Spotify playlists the track is included in.
# in_spotify_charts: Number of times the track appeared in Spotify charts.
# streams: Total number of streams the track has received.
# in_apple_playlists: Number of Apple Music playlists the track is included in.
# in_apple_charts: Number of times the track appeared in Apple Music charts.
# in_deezer_playlists: Number of Deezer playlists the track is included in.
# in_deezer_charts: Number of times the track appeared in Deezer charts.
# in_shazam_charts: Number of times the track appeared in Shazam charts.
# bpm: Beats per minute, a measure of the tempo or speed of the track.
# key: The musical key in which the track is composed.
# mode: The musical mode (major or minor) of the track.
# danceability_%: A percentage representing how suitable the track is for dancing based on its musical elements.
# valence_%: A percentage representing the overall positivity or happiness conveyed by the track.
# energy_%: A percentage representing the energy level of the track.
# acousticness_%: A percentage representing how acoustic the track is.
# instrumentalness_%: A percentage representing the amount of instrumental content in the track.
# liveness_%: A percentage representing the presence of live performance elements in the track.
#  speechiness_%: A percentage representing the presence of spoken words in the track.

df.shape
df.dtypes         #returns a series with the data type of each column

# Convert 'streams', 'in_deezer_playlists' columns to numerical data types

df['in_deezer_playlists'] = pd.to_numeric(df['in_deezer_playlists'], errors='coerce')

df['streams'] = pd.to_numeric(df['streams'], errors='coerce')

df['streams'].fillna(0, inplace=True)

df['in_deezer_playlists'].fillna(0, inplace=True)
df['streams']

df.columns         #provides access to the column labels of a data frame

df.duplicated().sum()  # checking duplicates  
df[df.duplicated()]

#checking which columns have null values in them
df.isnull().sum()

#   dealing with null data 
df['key'].fillna(0,inplace = True)
df['in_shazam_charts'].fillna(0, inplace = True)

df.info()
df["artist_count"].value_counts(normalize=True)

df.isna().sum()  # checking which columns have na values in them
df.count()         #counts the number of not empty values for each row, or column

#  renaming the column
df.rename(columns={"artist(s)_name":"artist_name"},inplace=True)
df.describe()

#  Handling missing, incorrect and invalid data
df.rename(columns={
    'artist(s)_name': 'artist_name',
    'danceability_%': 'danceability_percent',
    'valence_%': 'valence_percent',
    'energy_%': 'energy_percent',
    'acousticness_%': 'acousticness_percent',
    'instrumentalness_%': 'instrumentalness_percent',
    'liveness_%': 'liveness_percent',
    'speechiness_%': 'speechiness_percent'
}, inplace=True)                          
#function that alters the axis labels

df.head()

artist_streams = df.groupby('artist_name')['streams'].sum().sort_values(ascending=False)
artist_streams.head(10)

###   Graphical Vizualization

#creating a histogram plot of the 'artist_count' column using seaborn
plt.figure(figsize=(6, 2))
sns.histplot(df['artist_count'])

#distribution of categorical variables
plt.figure(figsize=(8, 4))
sns.countplot(x='key', data=df)
plt.title('Distribution of Keys')
plt.show()

sns.countplot(data=df, x='mode', hue='mode')
plt.xlabel('Mode')
plt.ylabel('Number of mode')
plt.title('Number of mode by mode')
bar_colors = ['tab:red', 'tab:blue']
plt.show()

# Top 10 artists name and tracks

leading_artists = df['artist_name'].value_counts().head(10)
plt.figure(figsize=(15,6))
sns.barplot(x = leading_artists.index, y = leading_artists)
plt.title('Top 10 artists with most number of tracks', fontsize=20, fontweight='bold')
plt.ylabel('Number of tracks',fontsize=15, fontweight='bold')
plt.xlabel('Artist Names',fontsize=15, fontweight='bold')
plt.show()

#   Top 10 most streamed songs on spotify in 2023

df['streams'] = pd.to_numeric(df['streams'], errors='coerce')
most_streamed_songs = df[['track_name', 'streams']].sort_values(by='streams', ascending=False).head(10)

plt.figure(figsize=(10,6))
sns.barplot(x = 'track_name', y = 'streams', data = most_streamed_songs)
plt.xticks(rotation=30)
plt.yticks(fontsize=20)
plt.xlabel('Names of songs', fontweight = 'bold', fontsize=15)
plt.ylabel('Count of streams', fontweight = 'bold', fontsize=20)
plt.title('Top 10 most streamed songs on spotify in 2023', fontweight = 'bold', fontsize=20)
plt.show()

#  Number of streams for beats per minute of a song
values_bpm = [
    df.loc[(df["bpm"]>=65) & (df["bpm"]<=105)]["streams"].mean(),
    df.loc[(df["bpm"]>=106) & (df["bpm"]<=125)]["streams"].mean(),
    df.loc[(df["bpm"]>=126) & (df["bpm"]<=145)]["streams"].mean(),
    df.loc[(df["bpm"]>=146) & (df["bpm"]<=165)]["streams"].mean(),
    df.loc[(df["bpm"]>=166) & (df["bpm"]<=185)]["streams"].mean(),
    df.loc[(df["bpm"]>=186) & (df["bpm"]<=206)]["streams"].mean(),
]
labels_bpm = ["65-105","106-125","126-145","146-165","166-185","186-206"]
sns.barplot(x =labels_bpm,y=values_bpm)
plt.title("Number of streams for beats per minute of a song")
plt.xlabel("Ranges of beats per minute of songs")
plt.ylabel("Number of streams")
plt.show()

released_year = df['released_year'].value_counts().reset_index()
released_year.columns = ['released_year', 'count']

# Plotting using Seaborn
plt.figure(figsize=(9, 3))
sns.barplot(x='released_year', y='count', data=released_year.head(14), palette='viridis')
plt.title('Number of Songs by release Year')
plt.xlabel('Release Year')
plt.ylabel('Number of Songs')
plt.show()

###  histograms
# Outliers

# plot all the histograms
df.hist(figsize=(14, 16), bins=50, xlabelsize=8, ylabelsize=8);
"""# There are a few things that you can discover from the histograms: 1. 'in_spotify_playlists', 
'in_apple_playlists', 'in_deezer_playlists'are positively skewed indicating most tracks are included in fewer 
playlists, with some tracks being outliers with high inclusion counts. 2. 'in_spotify_charts', 'in_apple_charts', 
'in_deezer_charts', 'in_shazam_charts'are similar to playlist inclusions, which are also positively skewed. 3. 
'streams' is also highly positively skewed. In order to reduce the dimensionality, i will combine ''in_spotify_playlists', 
'in_apple_playlists', 'in_deezer_playlists' into one column 'total_playlist'. And combine 'in_spotify_charts', 
'in_apple_charts', 'in_deezer_charts', 'in_shazam_charts' into one column 'total_charts'."""

#set the style for Seaborn plots
sns.set(style="whitegrid")

#plot histograms for each numeric column
plt.figure(figsize=(12, 6))

#histogram for numeric_column1
plt.subplot(1, 2, 1)
sns.histplot(df['bpm'], bins=10, kde=True, color='skyblue')
plt.title('Distribution of bpm')

#histogram for numeric_column2
plt.subplot(1, 2, 2)
sns.histplot(df['in_apple_charts'], bins=10, kde=True, color='salmon')
plt.title('Distribution of in_apple_charts')

plt.tight_layout()
plt.show()

Q1 = df.bpm.quantile(0.25)
Q3 = df.bpm.quantile(0.75)
Q1,  Q3

IQR = Q3 -Q1
IQR

lower_limit = Q1 - 1.5*IQR
upper_limit = Q1 + 1.5*IQR
lower_limit, upper_limit 

df[(df.bpm<lower_limit)|(df.bpm>upper_limit)]

heatmap
# Correlation matrix
correlation_matrix = df.corr()

# Set up the matplotlib figure
plt.figure(figsize=(14, 12))

# Draw the heatmap
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm', square=True, cbar_kws={"shrink": .5})

# Show the plot
plt.show()


""" You can see from above that there seems to be a strong positive correlation between streams and 
in_spotify_playlists, and in_deezer_playlist and in_spotifyplaylists. Likewise, there is a negative 
correlation between energy% and acousticness_%

What does this tell us? Songs in spotify playlists usually have more streams. 
This could be useful for marketers who now know that promoting songs via playlists can help that song be streamed more. 
This may seem intuitive but now we have the data to back it up.

Insights and Implications: The analysis highlighted that playlist inclusion and 
certain musical qualities are strong predictors of streaming success. This insight could guide artists and 
producers towards creating content with characteristics that align with these trends.

Recommendations: We recommend that stakeholders consider both the quantitative data and qualitative 
factors such as social media presence when predicting a song's success. Future campaigns should leverage 
the insights gained to strategically promote content. """
